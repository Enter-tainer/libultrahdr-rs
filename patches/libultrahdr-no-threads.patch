diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5128335..c2a1e46 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -28,16 +28,22 @@ project(libuhdr
 ###########################################################
 # Detect system
 ###########################################################
-if(${CMAKE_SYSTEM_NAME} MATCHES "Linux")
-elseif(${CMAKE_SYSTEM_NAME} MATCHES "Emscripten")
-elseif(${CMAKE_SYSTEM_NAME} MATCHES "Android")
-elseif(${CMAKE_SYSTEM_NAME} MATCHES "FreeBSD")
+if("${CMAKE_SYSTEM_NAME}" MATCHES "Linux")
+elseif("${CMAKE_SYSTEM_NAME}" MATCHES "Emscripten")
+elseif("${CMAKE_SYSTEM_NAME}" MATCHES "Android")
+elseif("${CMAKE_SYSTEM_NAME}" MATCHES "FreeBSD")
+elseif("${CMAKE_SYSTEM_NAME}" MATCHES "WASI")
 elseif(WIN32)
 elseif(APPLE)
 else()
   message(FATAL_ERROR "Platform ${CMAKE_SYSTEM_NAME} not recognized")
 endif()
 
+set(UHDR_TARGET_WASI FALSE)
+if("${CMAKE_SYSTEM_NAME}" MATCHES "WASI")
+  set(UHDR_TARGET_WASI TRUE)
+endif()
+
 if(CMAKE_SYSTEM_PROCESSOR MATCHES "amd64.*|x86_64.*|AMD64.*")
   if(CMAKE_SIZEOF_VOID_P EQUAL 8)
     set(ARCH "amd64")
@@ -60,6 +66,8 @@ elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^riscv32")
   set(ARCH "riscv32")
 elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^loongarch64")
   set(ARCH "loong64")
+elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^wasm32")
+  set(ARCH "wasm32")
 else()
   message(FATAL_ERROR "Architecture: ${CMAKE_SYSTEM_PROCESSOR} not recognized")
 endif()
@@ -132,6 +140,11 @@ option_if_not_defined(UHDR_ENABLE_INSTALL "Enable install and uninstall targets
 option_if_not_defined(UHDR_ENABLE_INTRINSICS "Build with SIMD acceleration " TRUE)
 option_if_not_defined(UHDR_ENABLE_GLES "Build with GPU acceleration " FALSE)
 option_if_not_defined(UHDR_ENABLE_WERROR "Build with -Werror" FALSE)
+set(UHDR_DISABLE_THREADS_DEFAULT FALSE)
+if(UHDR_TARGET_WASI)
+  set(UHDR_DISABLE_THREADS_DEFAULT TRUE)
+endif()
+option_if_not_defined(UHDR_DISABLE_THREADS "Build without std::thread usage (single-threaded)" ${UHDR_DISABLE_THREADS_DEFAULT})
 
 # These options effect only encoding process.
 # Decoding continues to support both iso and xmp irrespective of this configuration.
@@ -139,12 +152,16 @@ option_if_not_defined(UHDR_ENABLE_WERROR "Build with -Werror" FALSE)
 option_if_not_defined(UHDR_WRITE_XMP "Write gainmap metadata in XMP packet" FALSE)
 option_if_not_defined(UHDR_WRITE_ISO "Write gainmap metadata in ISO 21496_1 packet" TRUE)
 
+if(UHDR_TARGET_WASI AND NOT UHDR_DISABLE_THREADS)
+  message(FATAL_ERROR "WASI build requires UHDR_DISABLE_THREADS=ON")
+endif()
+
 # pre-requisites
-if(UHDR_BUILD_TESTS AND EMSCRIPTEN)
+if(UHDR_BUILD_TESTS AND (EMSCRIPTEN OR UHDR_TARGET_WASI))
   message(FATAL_ERROR "Building tests not supported for wasm targets")
 endif()
 
-if(UHDR_BUILD_BENCHMARK AND EMSCRIPTEN)
+if(UHDR_BUILD_BENCHMARK AND (EMSCRIPTEN OR UHDR_TARGET_WASI))
   message(FATAL_ERROR "Building benchmarks not supported for wasm targets")
 endif()
 
@@ -178,6 +195,10 @@ if(EMSCRIPTEN AND BUILD_SHARED_LIBS)
   set(BUILD_SHARED_LIBS FALSE)
   message(STATUS "For wasm targets, build and use static libraries")
 endif()
+if(UHDR_TARGET_WASI AND BUILD_SHARED_LIBS)
+  set(BUILD_SHARED_LIBS FALSE)
+  message(STATUS "For WASI targets, build and use static libraries")
+endif()
 
 if(MSVC AND (UHDR_BUILD_DEPS OR UHDR_BUILD_TESTS OR UHDR_BUILD_BENCHMARK) AND BUILD_SHARED_LIBS)
   # ExternalProject_Add() for jpeg, gtest, google benchmarks is configured to build static libraries
@@ -265,6 +286,12 @@ if(MSVC)
   add_compile_options(/wd4305) # truncation from 'double' to 'float'
   add_compile_options(/wd4838) # conversion from 'type1' to 'type2' requires a narrowing conversion
   add_compile_options(/wd26812) # Prefer enum class over enum
+elseif(UHDR_TARGET_WASI)
+  add_compile_options(-ffunction-sections)
+  add_compile_options(-fdata-sections)
+  add_compile_options(-fomit-frame-pointer)
+  add_compile_options(-ffp-contract=fast)
+  add_compile_options(-D__wasm_exception_handling__)
 elseif(EMSCRIPTEN)
   if(NOT UHDR_BUILD_DEPS)
     include(CheckCSourceCompiles)
@@ -374,9 +401,11 @@ if(${CMAKE_SYSTEM_NAME} MATCHES "Android")
 endif()
 
 # Threads
-set(CMAKE_THREAD_PREFER_PTHREAD ON)
-set(THREADS_PREFER_PTHREAD_FLAG ON)
-find_package(Threads REQUIRED)
+if(NOT UHDR_DISABLE_THREADS)
+  set(CMAKE_THREAD_PREFER_PTHREAD ON)
+  set(THREADS_PREFER_PTHREAD_FLAG ON)
+  find_package(Threads REQUIRED)
+endif()
 
 include(ExternalProject)
 
@@ -481,6 +510,8 @@ if(NOT JPEG_FOUND)
         PREFIX ${JPEGTURBO_PREFIX_DIR}
         SOURCE_DIR ${JPEGTURBO_SOURCE_DIR}
         BINARY_DIR ${JPEGTURBO_BINARY_DIR}
+        DOWNLOAD_COMMAND ""
+        UPDATE_COMMAND ""
         CONFIGURE_COMMAND emcmake cmake ${JPEGTURBO_SOURCE_DIR}
                           -DENABLE_SHARED=0 -DWITH_SIMD=0
         BUILD_COMMAND ${CMAKE_COMMAND} --build <BINARY_DIR> --config $<CONFIG> --target jpeg-static
@@ -488,14 +519,20 @@ if(NOT JPEG_FOUND)
         INSTALL_COMMAND ""
     )
   else()
+    set(JPEGTURBO_ARGS ${UHDR_CMAKE_ARGS})
+    if(UHDR_TARGET_WASI)
+      list(APPEND JPEGTURBO_ARGS -DWITH_SIMD=0)
+    endif()
     ExternalProject_Add(${JPEGTURBO_TARGET_NAME}
         GIT_REPOSITORY https://github.com/libjpeg-turbo/libjpeg-turbo.git
         GIT_TAG 3.1.0
         PREFIX ${JPEGTURBO_PREFIX_DIR}
         SOURCE_DIR ${JPEGTURBO_SOURCE_DIR}
         BINARY_DIR ${JPEGTURBO_BINARY_DIR}
+        DOWNLOAD_COMMAND ""
+        UPDATE_COMMAND ""
         BUILD_COMMAND ${CMAKE_COMMAND} --build <BINARY_DIR> --config $<CONFIG> --target jpeg-static
-        CMAKE_ARGS ${UHDR_CMAKE_ARGS} -DENABLE_SHARED=0
+        CMAKE_ARGS ${JPEGTURBO_ARGS} -DENABLE_SHARED=0
         BUILD_BYPRODUCTS ${JPEG_LIBRARIES}
         INSTALL_COMMAND ""
     )
@@ -604,7 +641,10 @@ file(GLOB UHDR_BM_SRCS_LIST "${BENCHMARK_DIR}/*.cpp")
 file(GLOB IMAGE_IO_SRCS_LIST "${THIRD_PARTY_DIR}/image_io/src/**/*.cc")
 
 set(PRIVATE_INCLUDE_DIR ${SOURCE_DIR}/include/ ${JPEG_INCLUDE_DIRS})
-set(PRIVATE_LINK_LIBS ${JPEG_LIBRARIES} Threads::Threads)
+set(PRIVATE_LINK_LIBS ${JPEG_LIBRARIES})
+if(NOT UHDR_DISABLE_THREADS)
+  list(APPEND PRIVATE_LINK_LIBS Threads::Threads)
+endif()
 if(UHDR_ENABLE_GLES)
   list(APPEND PRIVATE_INCLUDE_DIR ${EGL_INCLUDE_DIRS} ${OPENGLES3_INCLUDE_DIRS})
   list(APPEND PRIVATE_LINK_LIBS ${EGL_LIBRARIES} ${OPENGLES3_LIBRARIES})
@@ -623,6 +663,9 @@ target_include_directories(${IMAGEIO_TARGET_NAME} PRIVATE
 set(UHDR_CORE_LIB_NAME core)
 add_library(${UHDR_CORE_LIB_NAME} STATIC ${UHDR_CORE_SRCS_LIST})
 target_compile_options(${UHDR_CORE_LIB_NAME} PRIVATE ${UHDR_WERROR_FLAGS})
+if(UHDR_DISABLE_THREADS)
+  target_compile_definitions(${UHDR_CORE_LIB_NAME} PUBLIC UHDR_NO_THREADS)
+endif()
 if(NOT JPEG_FOUND)
   add_dependencies(${UHDR_CORE_LIB_NAME} ${JPEGTURBO_TARGET_NAME})
 endif()
diff --git a/lib/src/jpegr.cpp b/lib/src/jpegr.cpp
index 284697f..6b6f898 100644
--- a/lib/src/jpegr.cpp
+++ b/lib/src/jpegr.cpp
@@ -21,11 +21,16 @@
 #include <unistd.h>
 #endif
 
-#include <condition_variable>
 #include <deque>
 #include <functional>
+#include <tuple>
+#include <vector>
+
+#ifndef UHDR_NO_THREADS
+#include <condition_variable>
 #include <mutex>
 #include <thread>
+#endif
 
 #include "ultrahdr/editorhelper.h"
 #include "ultrahdr/gainmapmetadata.h"
@@ -71,6 +76,7 @@ static const string kIsoNameSpace = "urn:iso:std:iso:ts:21496:-1";
 static_assert(kWriteXmpMetadata || kWriteIso21496_1Metadata,
               "Must write gain map metadata in XMP format, or iso 21496-1 format, or both.");
 
+#ifndef UHDR_NO_THREADS
 class JobQueue {
  public:
   bool dequeueJob(unsigned int& rowStart, unsigned int& rowEnd);
@@ -124,6 +130,28 @@ void JobQueue::reset() {
   mJobs.clear();
   mQueuedAllJobs = false;
 }
+#else
+// Single-threaded fallback for targets without std::thread support.
+class JobQueue {
+ public:
+  bool dequeueJob(unsigned int& rowStart, unsigned int& rowEnd) {
+    if (mJobs.empty()) return false;
+    auto it = mJobs.begin();
+    rowStart = std::get<0>(*it);
+    rowEnd = std::get<1>(*it);
+    mJobs.pop_front();
+    return true;
+  }
+  void enqueueJob(unsigned int rowStart, unsigned int rowEnd) {
+    mJobs.push_back(std::make_tuple(rowStart, rowEnd));
+  }
+  void markQueueForEnd() {}
+  void reset() { mJobs.clear(); }
+
+ private:
+  std::deque<std::tuple<unsigned int, unsigned int>> mJobs;
+};
+#endif
 
 /*
  * MessageWriter implementation for ALOG functions.
@@ -136,7 +164,31 @@ class AlogMessageWriter : public MessageWriter {
   }
 };
 
+#ifdef UHDR_NO_THREADS
+unsigned int GetCPUCoreCount() { return 1u; }
+#else
 unsigned int GetCPUCoreCount() { return (std::max)(1u, std::thread::hardware_concurrency()); }
+#endif
+
+#ifndef UHDR_NO_THREADS
+using WorkerThread = std::thread;
+template <class Fn>
+void StartWorkers(int threads, const Fn& fn, std::vector<WorkerThread>& workers) {
+  for (int th = 0; th < threads - 1; th++) {
+    workers.emplace_back(fn);
+  }
+}
+template <class WorkerVec>
+void JoinWorkers(WorkerVec& workers) {
+  std::for_each(workers.begin(), workers.end(), [](std::thread& t) { t.join(); });
+}
+#else
+struct WorkerThread {};
+template <class Fn>
+void StartWorkers(int /*threads*/, const Fn& /*fn*/, std::vector<WorkerThread>& /*workers*/) {}
+template <class WorkerVec>
+void JoinWorkers(WorkerVec& /*workers*/) {}
+#endif
 
 JpegR::JpegR(void* uhdrGLESCtxt, int mapDimensionScaleFactor, int mapCompressQuality,
              bool useMultiChannelGainMap, float gamma, uhdr_enc_preset_t preset,
@@ -818,10 +870,8 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
     };
 
     // generate map
-    std::vector<std::thread> workers;
-    for (int th = 0; th < threads - 1; th++) {
-      workers.push_back(std::thread(generateMap));
-    }
+    std::vector<WorkerThread> workers;
+    StartWorkers(threads, generateMap, workers);
 
     for (unsigned int rowStart = 0; rowStart < map_height;) {
       unsigned int rowEnd = (std::min)(rowStart + rowStep, map_height);
@@ -830,7 +880,7 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
     }
     jobQueue.markQueueForEnd();
     generateMap();
-    std::for_each(workers.begin(), workers.end(), [](std::thread& t) { t.join(); });
+    JoinWorkers(workers);
   };
 
   auto generateGainMapTwoPass = [this, sdr_intent, hdr_intent, gainmap_metadata, dest, map_width,
@@ -843,7 +893,9 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
     float* gainmap_data = reinterpret_cast<float*>(gainmap_mem.m_buffer.get());
     float gainmap_min[3] = {127.0f, 127.0f, 127.0f};
     float gainmap_max[3] = {-128.0f, -128.0f, -128.0f};
+#ifndef UHDR_NO_THREADS
     std::mutex gainmap_minmax;
+#endif
 
     const int threads = (std::min)(GetCPUCoreCount(), 4u);
     const int jobSizeInRows = 1;
@@ -853,7 +905,11 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
         [this, sdr_intent, hdr_intent, gainmap_data, map_width, hdrInvOetf, hdrLuminanceFn,
          hdrOotfFn, hdrGamutConversionFn, sdrGamutConversionFn, luminanceFn, sdrYuvToRgbFn,
          hdrYuvToRgbFn, sdr_sample_pixel_fn, hdr_sample_pixel_fn, hdr_white_nits, use_luminance,
-         &gainmap_min, &gainmap_max, &gainmap_minmax, &jobQueue]() -> void {
+         &gainmap_min, &gainmap_max,
+#if !defined(UHDR_NO_THREADS)
+         &gainmap_minmax,
+#endif
+         &jobQueue]() -> void {
       unsigned int rowStart, rowEnd;
       const bool isHdrIntentRgb = isPixelFormatRgb(hdr_intent->fmt);
       const bool isSdrIntentRgb = isPixelFormatRgb(sdr_intent->fmt);
@@ -928,6 +984,7 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
           }
         }
       }
+#if !defined(UHDR_NO_THREADS)
       {
         std::unique_lock<std::mutex> lock{gainmap_minmax};
         for (int index = 0; index < (mUseMultiChannelGainMap ? 3 : 1); index++) {
@@ -935,13 +992,17 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
           gainmap_max[index] = (std::max)(gainmap_max[index], gainmap_max_th[index]);
         }
       }
+#else
+      for (int index = 0; index < (mUseMultiChannelGainMap ? 3 : 1); index++) {
+        gainmap_min[index] = (std::min)(gainmap_min[index], gainmap_min_th[index]);
+        gainmap_max[index] = (std::max)(gainmap_max[index], gainmap_max_th[index]);
+      }
+#endif
     };
 
     // generate map
-    std::vector<std::thread> workers;
-    for (int th = 0; th < threads - 1; th++) {
-      workers.push_back(std::thread(generateMap));
-    }
+    std::vector<WorkerThread> workers;
+    StartWorkers(threads, generateMap, workers);
 
     for (unsigned int rowStart = 0; rowStart < map_height;) {
       unsigned int rowEnd = (std::min)(rowStart + rowStep, map_height);
@@ -950,7 +1011,7 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
     }
     jobQueue.markQueueForEnd();
     generateMap();
-    std::for_each(workers.begin(), workers.end(), [](std::thread& t) { t.join(); });
+    JoinWorkers(workers);
 
     // xmp metadata current implementation does not support writing multichannel metadata
     // so merge them in to one
@@ -1015,9 +1076,7 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
     workers.clear();
     jobQueue.reset();
     rowStep = threads == 1 ? map_height : 1;
-    for (int th = 0; th < threads - 1; th++) {
-      workers.push_back(std::thread(encodeMap));
-    }
+    StartWorkers(threads, encodeMap, workers);
     for (unsigned int rowStart = 0; rowStart < map_height;) {
       unsigned int rowEnd = (std::min)(rowStart + rowStep, map_height);
       jobQueue.enqueueJob(rowStart, rowEnd);
@@ -1025,7 +1084,7 @@ uhdr_error_info_t JpegR::generateGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_
     }
     jobQueue.markQueueForEnd();
     encodeMap();
-    std::for_each(workers.begin(), workers.end(), [](std::thread& t) { t.join(); });
+    JoinWorkers(workers);
 
     if (mUseMultiChannelGainMap) {
       for (int i = 0; i < 3; i++) {
@@ -1686,10 +1745,8 @@ uhdr_error_info_t JpegR::applyGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_ima
   };
 
   const int threads = (std::min)(GetCPUCoreCount(), 4u);
-  std::vector<std::thread> workers;
-  for (int th = 0; th < threads - 1; th++) {
-    workers.push_back(std::thread(applyRecMap));
-  }
+  std::vector<WorkerThread> workers;
+  StartWorkers(threads, applyRecMap, workers);
   const unsigned int rowStep = threads == 1 ? sdr_intent->h : map_scale_factor_rnd;
   for (unsigned int rowStart = 0; rowStart < sdr_intent->h;) {
     unsigned int rowEnd = (std::min)(rowStart + rowStep, sdr_intent->h);
@@ -1698,7 +1755,7 @@ uhdr_error_info_t JpegR::applyGainMap(uhdr_raw_image_t* sdr_intent, uhdr_raw_ima
   }
   jobQueue.markQueueForEnd();
   applyRecMap();
-  std::for_each(workers.begin(), workers.end(), [](std::thread& t) { t.join(); });
+  JoinWorkers(workers);
 
   return g_no_error;
 }
@@ -2076,10 +2133,8 @@ uhdr_error_info_t JpegR::toneMap(uhdr_raw_image_t* hdr_intent, uhdr_raw_image_t*
   };
 
   // tone map
-  std::vector<std::thread> workers;
-  for (int th = 0; th < threads - 1; th++) {
-    workers.push_back(std::thread(toneMapInternal));
-  }
+  std::vector<WorkerThread> workers;
+  StartWorkers(threads, toneMapInternal, workers);
 
   for (unsigned int rowStart = 0; rowStart < height;) {
     unsigned int rowEnd = (std::min)(rowStart + rowStep, height);
@@ -2088,7 +2143,7 @@ uhdr_error_info_t JpegR::toneMap(uhdr_raw_image_t* hdr_intent, uhdr_raw_image_t*
   }
   jobQueue.markQueueForEnd();
   toneMapInternal();
-  std::for_each(workers.begin(), workers.end(), [](std::thread& t) { t.join(); });
+  JoinWorkers(workers);
 
   return g_no_error;
 }
